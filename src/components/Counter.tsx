'use client';

/**
  서버 컴포넌트는 서버에서 동작하기 때문에 브라우저단에서 일어나는 일 사용자의 클릭 이벤트를 처리한다던지,
  상태를 가진다던지, 컴포넌트가 마운트 되었을 때 쓸 수 있는 useEffect라던지 이런 브라우저에서만 할 수 있는 일들은
  서버 컴포넌트에서는 할 수가 없었다.

  그래서 특정 페이지 안에서 사용자의 이벤트를 처리해야되거나 useState나 useEffect를 사용해야 된다면 컴포넌트를 클라이언트 컴포넌트로
  만들어서 사용해야 한다.
  클라이언트 컴포넌트로 만드려면 코드 최상단에 'use client'라고 적어주면 된다.
 */
import React, { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState<number>(0);

  // 페이지가 로딩 될 때 처음으로 받아지는 정적 페이지에는 클라이언트 컴포넌트도 포함이 되어 있다. 그래서 서버 로그 상에도 출력이 된다.
  // 클라이언트 컴포넌트라는 말은 무조건 그 클라이언트 컴포넌트가 클라이언트 사이드 렌더링이 된다는 말이 아니라
  // 사용자의 클릭을 처리한다던지 무언가 클라이언트에서 실행 되어야 되는 코드를 클라이언트 컴포넌트라고 하고
  // 그 코드가 클라이언트에 보내지는 것을 클라이언트 컴포넌트라고 할 수 있다.

  // 페이지가 로딩 될 때 처음으로 받아진 정적 페이지에는 클라이언트 컴포넌트 상에 있는 정적인 데이터가 포함이 되어 있지만
  //  그 HTML상에서 클릭 이벤트는 처리 되지 않는다.
  // 이후에 자바스크립트 코드와 리액트 코드가 다운 받아와진 후에 즉 하이드레이션 된 후에야 이벤트가 처리되고
  // 이 클라이언트 컴포넌트와 전체적인 웹어플리케이션을 구동하는데 필요한 코드들은 리액트 컴포넌트로 변환이 된다.
  console.log('안녕!! - 클라이언트');

  const increse = () => {
    setCount((prev) => prev + 1);
  };

  const decrese = () => {
    setCount((prev) => prev - 1);
  };

  return (
    <>
      <h1>{count}</h1>
      <button onClick={increse}>증가</button>
      <button onClick={decrese}>감소</button>
    </>
  );
}
